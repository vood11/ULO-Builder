#!/usr/bin/env bash
#
# Copyright (c) 2023 ulo
#
# Licensed under the MIT.
#
lolcat=/usr/games/lolcat

ver="1.4"
tmp="./tmp"
out="./out"
minsize=1024

amlogic=`ls -l ./core/loader/amlogic | grep s9 | awk '{ print $9 }' | cut -d. -f1`
allwinner=`ls -l ./core/loader/allwinner | grep u-boot-sunxi-with-spl | awk '{ print $9 }' | cut -c 23- | cut -d. -f1`
rockchip=`ls -l ./core/loader/rockchip | grep idbloader | awk '{ print $9 }' | cut -c 11- | cut -d. -f1`

device_path="./device"
kernel_path="./core/kernel"
rootfs_path="./rootfs"
fwdriver_path="./core/root/lib"

ulo_repo="armarchindo/ULO-repository"
rootfs_repo="armarchindo/rootfs-openwrt"

custom_kernel_repo="armarchindo/kernel"
custom_kernel_release_tag="kernel_dbai"
custom_kernel_versions=( "5.19.16" "5.19.17" "5.15.76" "6.1.66" )

DOWNLOAD_CUSTOM_KERNELS=false
# REVISI: Menambahkan variabel kontrol untuk Custom RootFS
DOWNLOAD_CUSTOM_ROOTFS=false

selected_patch=""

start_cnt=$SECONDS

die() {
    echo -e "ERROR: $1"
    exit 1
}

download_and_extract_custom_kernels() {
    if [ ${#custom_kernel_versions[@]} -eq 0 ]; then
        echo "No kernel versions specified in 'custom_kernel_versions', process skipped."
        return
    fi

    echo "Fetching kernel list from release '$custom_kernel_release_tag'..." | $lolcat
    
    local api_url="https://api.github.com/repos/$custom_kernel_repo/releases/tags/$custom_kernel_release_tag"
    
    local assets_info=$(curl -s "$api_url" | jq -r '.assets[] | "\(.name) \(.browser_download_url)"')

    if [ -z "$assets_info" ]; then
        echo "ERROR: Failed to fetch asset list. Check repository name and release tag."
        return
    fi

    echo "Starting custom kernel download..." | $lolcat -a -d 5
    
    local temp_download_dir="./tmp_kernels_dl"
    mkdir -p "$temp_download_dir"

    for version in "${custom_kernel_versions[@]}"; do
        local archive_name="${version}.tar.gz"
        local extract_dir="${kernel_path}/${version}"

        local download_url=$(echo "$assets_info" | grep "^${archive_name} " | awk '{print $2}')

        echo "----------------------------------------"
        
        if [ -z "$download_url" ]; then
            echo "-> WARNING: Kernel '${archive_name}' not found in release assets. Skipped."
            continue
        fi

        echo "-> Downloading: ${archive_name}" | $lolcat

        if aria2c --console-log-level=warn --dir="$temp_download_dir" -o "$archive_name" "$download_url"; then
            echo "-> Extracting ${archive_name} to ${extract_dir}/"
            mkdir -p "$extract_dir"
            
            if tar -xzf "${temp_download_dir}/${archive_name}" -C "$extract_dir/" --strip-components=1; then
                echo "   Extraction successful."
            else
                echo "   ERROR: Failed to extract ${archive_name}."
            fi
        else
            echo "   ERROR: Failed to download ${archive_name}."
        fi
    done

    rm -rf "$temp_download_dir"
    echo "----------------------------------------"
    echo "Custom kernel download process completed." | $lolcat -a -d 5
}

check_depedencies() {
    local pkgs_to_install=()
    req=(lolcat pigz aria2 wget jq unrar)

    if command -v pacman &>/dev/null; then
        lolcat="/usr/bin/lolcat"
        req+=(p7zip)
        for pkg in "${req[@]}"; do
            pacman -Qq "$pkg" &>/dev/null || pkgs_to_install+=("$pkg")
        done
    else
        req+=(p7zip-full)
        for pkg in "${req[@]}"; do
            dpkg -s "$pkg" &>/dev/null || pkgs_to_install+=("$pkg")
        done
    fi

    if [ ${#pkgs_to_install[@]} -gt 0 ]; then
        echo -e "Preparing to install dependencies..."
        
        if command -v pacman &>/dev/null; then
            for pkg in "${pkgs_to_install[@]}"; do
                echo "  Installing $pkg..."
                sudo pacman -S --noconfirm "$pkg" > /dev/null 2>&1
            done
        else
            for pkg in "${pkgs_to_install[@]}"; do
                echo "  Installing $pkg..."
                sudo apt-get -y install "$pkg" > /dev/null 2>&1
            done
        fi
        
        echo -e "Done!!!"
    fi
}

# REVISI: Fungsi ini diubah agar dikontrol oleh variabel DOWNLOAD_CUSTOM_ROOTFS
custom_rootfs_files() {
    if [ "$DOWNLOAD_CUSTOM_ROOTFS" = false ]; then
        echo -e "Custom ROOTFS download skipped by configuration."
        return
    fi

    echo -e "Downloading custom ROOTFS Files..." | $lolcat -a -d 5
    local long_url="https://api.github.com/repos/$rootfs_repo/releases"
    local json_data=$(curl -s "$long_url")
    local list_url=$(echo "$json_data" | jq -r '.[].assets[].browser_download_url')

    if [ -z "$list_url" ]; then
        echo "WARNING: No custom RootFS found or failed to fetch from GitHub API."
        return
    fi
    
    for url in $list_url; do
        echo "Downloading $(basename "$url")..."
        aria2c --console-log-level=warn -d rootfs "$url"
    done
    
    echo -e "Custom ROOTFS download completed." | $lolcat -a -d 5
}

check_requirement_files() {
    statx=0
    find_devices
    find_rootfs
    find_kernels
    [ ${#devices[*]} = 0 ] && die "No ${device_path:2} file or directory!"
    [ ${#rootfs[*]} = 0 ] && statx=1
    [ ${#kernels[*]} = 0 ] &&  statx=2
    [ -d "${fwdriver_path}/firmware" ] || statx=3
    if [ $statx = 1 ]; then
        echo -e "ROOTFS files not available!"
        download_requirement_files false
    elif [ $statx = 2 ]; then
        echo -e "ULO Builder dependencies not found!"
        download_requirement_files false
    elif [ $statx = 3 ]; then
        echo -e "ULO dependencies not found!"
        download_requirement_files false
    fi
}

download_requirement_files() {
    local tmp_path="./tmp"
    local cmd=$1
    if [ $cmd = true ]; then
        rm -rf ./core/kernel/*
        rm -rf ./rootfs/*
        rm -rf $fwdriver_path/firmware
    fi
    [ -d "${tmp_path}" ] || mkdir -p $tmp_path

    if [ ! -f "${tmp_path}/data.zip" ]; then
        echo -e "Downloading KERNEL, ROOTFS, & Driver Firmware" | $lolcat -a -d 1
        aria2c --console-log-level=warn --out=${tmp_path}/data.zip "https://github.com/${ulo_repo}/archive/refs/heads/main.zip"
        echo -e "Unzipping KERNEL, ROOTFS, & Driver Firmware" | $lolcat -a -d 1
        unzip -q $tmp_path/data.zip -d $tmp_path
        cp -rf $tmp_path/ULO-repository-main/kernel ./core/
        cp -rf $tmp_path/ULO-repository-main/rootfs ./
        cp -rf $tmp_path/ULO-repository-main/firmware $fwdriver_path/
        echo -e "Done..." | $lolcat -a -d 5
        rm -r $tmp_path
    fi
    echo -e "All required files are present." | $lolcat -a -d 1
    
    if [ "$DOWNLOAD_CUSTOM_KERNELS" = true ]; then
        download_and_extract_custom_kernels
    fi

    # REVISI: Memanggil fungsi custom_rootfs_files yang sudah non-interaktif
    custom_rootfs_files
    
    find_devices
    find_rootfs
    find_kernels
}

cleaning() {
    for x in $(lsblk | grep $(pwd) | grep -oE 'loop[0-9]+' | sort | uniq); do
        umount -f /dev/${x}p[1-2] 2>/dev/null
        umount -f /dev/$x 2>/dev/null
        losetup -d /dev/$x 2>/dev/null
        losetup -D 2>/dev/null
    done
    rm -rf $tmp
    [ "$1" ] || rm -rf $out
}

kernel_checker() {
    local kernelx=$1
    local cmdx=$2
    local is_amlogic=false
    local is_allwinner=false
    local is_rockchip=false
    local kinfo=`ls core/kernel/${kernelx} | grep dtb | cut -d- -f2`

    echo $amlogic | grep -iq $device && is_amlogic=true
    echo $allwinner | grep -iq $device && is_allwinner=true
    echo $rockchip | grep -iq $device && is_rockchip=true
    
    if [ "$is_amlogic" = true ] && [ "$kinfo" = "amlogic" ]; then
        [ "$cmdx" = false ] && echo -e "${kernel}\n" | $lolcat -a -d 5
    elif [ "$is_allwinner" = true ] && [ "$kinfo" = "allwinner" ]; then
        [ "$cmdx" = false ] && echo -e "${kernel}\n" | $lolcat -a -d 5
    elif [ "$is_rockchip" = true ] && [ "$kinfo" = "rockchip" ]; then
        [ "$cmdx" = false ] && echo -e "${kernel}\n" | $lolcat -a -d 5
    elif [ "$cmdx" = true ]; then
        die "This kernel is for ${kinfo} devices!!!"
    else
        echo "This kernel is for ${kinfo} devices!!!"
        echo "Please re-select"
        find_kernels
        choose_kernel
    fi
}

find_devices() {
    local path=$device_path
    [ -d $path ] || return
    local len=0
    IFS=$'\n'
    devices=()
    for x in $(ls $path); do
        [ -f $path/$x/boot-*.tar.gz ] && devices[len++]=$x
    done
}

find_kernels() {
    local path=$kernel_path
    [ -d $path ] || return
    local len=0
    IFS=$'\n'
    kernels=()
    for x in $(ls $path); do
        if [ -d "$path/$x" ]; then
            if [ -n "$(ls "$path/$x"/dtb-*.tar.gz 2>/dev/null)" ] && \
               [ -n "$(ls "$path/$x"/boot-*.tar.gz 2>/dev/null)" ] && \
               [ -n "$(ls "$path/$x"/modules-*.tar.gz 2>/dev/null)" ]; then
                kernels[len++]=$x
            fi
        fi
    done
}

find_rootfs() {
    local path=$rootfs_path
    [ -d $path ] || return
    local len=0
    IFS=$'\n'
    rootfs=()
    for x in $(ls $path); do
        rootfs[len++]=$x
    done
}

choose_device() {
    local i=0
    echo -e "Chipset: " | $lolcat -a -d 5
    choose_option ${#devices[@]} "" "${devices[@]}"
    local opt=$?
    device=${devices[opt]}
    devices=($device)
    echo -e "${device}\n" | $lolcat -a -d 5
}

choose_rootfs() {
    local i=0
    echo -e "ROOTFS: " | $lolcat -a -d 5
    choose_option ${#rootfs[@]} "" "${rootfs[@]}"
    local opt=$?
    firmware=${rootfs[opt]}
    echo -e "${firmware}\n" | $lolcat -a -d 5
    echo $firmware > $rootfs_path/rootfs.log
}

choose_kernel() {
    local i=0
    local filtered_kernels=()

    for kernel in "${kernels[@]}"; do
        local kinfo=$(ls "core/kernel/${kernel}" | grep dtb | cut -d- -f2)
        if [ "$kinfo" = "amlogic" ] && echo $amlogic | grep -iq $device; then
            filtered_kernels+=("$kernel")
        elif [ "$kinfo" = "allwinner" ] && echo $allwinner | grep -iq $device; then
            filtered_kernels+=("$kernel")
        elif [ "$kinfo" = "rockchip" ] && echo $rockchip | grep -iq $device; then
            filtered_kernels+=("$kernel")
        fi
    done

    if [ ${#filtered_kernels[@]} -eq 0 ]; then
        echo -e "\nERROR: No suitable kernel found for device '$device'." | $lolcat
        echo -e "Ensure the appropriate kernel exists in './core/kernel/' and try again."
        exit 1
    fi

    echo -e "Kernel:" | $lolcat -a -d 5
    choose_option ${#filtered_kernels[@]} "kernel" "${filtered_kernels[@]}"
    local opt=$?
    kernel=${filtered_kernels[opt]}
    kernels=($kernel)
    kernel_checker "${kernel}" false
}

# --- PERBAIKAN DIMULAI DI SINI ---
choose_patch() {
    local patch_path="./patch"
    if [ ! -d "$patch_path" ]; then
        echo "Direktori patch tidak ditemukan. Melewati..."
        return
    fi

    local patches=()
    # Mengisi array 'patches' dengan nama file dari direktori patch
    while IFS= read -r -d $'\0'; do
        patches+=("$(basename "$p")")
    done < <(find "$patch_path" -maxdepth 1 -type f -print0)

    # Logika Otomatis untuk Lingkungan Non-Interaktif (GitHub Actions)
    if [ ${#patches[@]} -eq 1 ]; then
        # Jika hanya ada SATU file patch, langsung pilih file itu.
        selected_patch=${patches[0]}
        echo "Satu patch ditemukan, memilih secara otomatis: ${selected_patch}" | $lolcat -a -d 5
        return # Keluar dari fungsi, tidak perlu tanya pengguna
    fi
    
    if [ ${#patches[@]} -eq 0 ]; then
        echo "Tidak ada arsip patch di direktori 'patch'. Melewati..."
        return
    fi

    # Logika Interaktif (Jika dijalankan manual dan ada >1 patch)
    local options=("Lewati (Tanpa patch)" "${patches[@]}")

    echo -e "Pilih patch yang akan diterapkan:" | $lolcat -a -d 5
    choose_option ${#options[@]} "" "${options[@]}"

    local opt=$?
    if [ $opt -ne 0 ]; then
        # Opsi 0 adalah "Lewati", jadi kita pilih selain itu
        selected_patch=${options[$opt]}
        echo -e "Patch yang dipilih: ${selected_patch}\n" | $lolcat -a -d 5
    else
        selected_patch=""
        echo -e "Patch dilewati.\n"
    fi
}
# --- PERBAIKAN SELESAI DI SINI ---


choose_option() {
    local len=$1
    local optx=$2
    shift 2
    local options=("$@")
    local i=0

    if [ "$optx" != "kernel" ]; then
        for x in "${options[@]}"; do
            echo -e "($((++i))) => $x"
        done
    else
        for x in "${options[@]}"; do
            local kinfo=$(ls "core/kernel/${x}" | grep dtb | cut -d- -f2)
            if [ "$kinfo" = 'amlogic' ]; then
                kinfo='Amlogic  '
            elif [ "$kinfo" = 'allwinner' ]; then
                kinfo='AllWinner'
            elif [ "$kinfo" = 'rockchip' ]; then
                kinfo='Rockchip '
            else
                kinfo='Undefined'
            fi
            echo -e "($((++i))) => $kinfo $x"
        done
    fi

    [ "$len" = 1 ] && return 0

    local cnt=0
    while [ $cnt -lt 3 ]; do
        echo "Select Number:" | $lolcat -a -d 5
        while read -r -t 0; do read -r; done
        read -p "" opt
        if [ ! "$opt" ]; then
            opt=0
            break
        elif [[ "$opt" -ge 1 && "$opt" -le "$len" ]] 2>/dev/null; then
            ((opt--))
            break
        else
            ((cnt++))
            echo -e "Invalid selection..."
            sleep 1s
        fi
    done

    [ $cnt = 3 ] && die "Too many invalid attempts. Exiting..."
    return $opt
}

make_losetup() {
    local path=$1
    loop=$(losetup -Pf --show $path)
    [ $loop ] || die "Error: Failed to set up loop device for ${path:2}"

    [ $2 ] && return 0

    loop_seq=$(ls $loop | grep -oE 'loop[0-9]+')

    mount="$tmp/mount"
    mkdir -p $mount

    [ -e ${loop}p1 ] && {
        mkdir -p $mount/${loop_seq}p1
        mount ${loop}p1 $mount/${loop_seq}p1
    }
    [ -e ${loop}p2 ] && {
        mkdir -p $mount/${loop_seq}p2
        mount ${loop}p2 $mount/${loop_seq}p2
    }
    
    [[ ! -e ${loop}p1 && ! -e ${loop}p2 && -e ${loop} ]] && {
        mkdir -p $mount/${loop_seq}
        mount ${loop} $mount/${loop_seq}
    }
}

apply_patch() {
    if [ -z "$selected_patch" ]; then
        return
    fi

    local patch_file="./patch/$selected_patch"
    local rootfs_target="$common_root"

    echo "Applying patch: $selected_patch..." | $lolcat -a -d 5

    echo "Patch type: Archive. Extracting files..."
    case "$patch_file" in
        *.zip)
            unzip -o "$patch_file" -d "$rootfs_target" >/dev/null 2>&1
            ;;
        *.rar)
            unrar x -o+ "$patch_file" "$rootfs_target/" >/dev/null 2>&1
            ;;
        *.tar.gz|*.gz|*.tar.xz|*.xz)
            tar xf "$patch_file" -C "$rootfs_target"
            ;;
        *.7z)
            7z x "$patch_file" -o"$rootfs_target" -y >/dev/null 2>&1
            ;;
        *)
            echo "Warning: Unrecognized archive format '$selected_patch'. Skipped."
            return
            ;;
    esac
    echo "Patch archive applied successfully." | $lolcat
}

unpack_openwrt() {
    local path="$rootfs_path/$firmware"
    local suffix="${firmware##*.}"
    common_root="$tmp/core/root"
    start_build=$SECONDS

    mkdir -p $common_root

    while true; do
        case "$suffix" in
            xz)
                xz -dc $path > $tmp/${firmware%.*}
                path=$tmp/${firmware%.*}
                suffix=${path##*.}
            ;;
            gz) 
                if ls $path | grep -q '.tar.gz$'; then
                    tar xzf $path -C $common_root
                    break
                else
                    gzip -dc $path > $tmp/${firmware%.*}
                    path=$tmp/${firmware%.*}
                    suffix=${path##*.}
                fi
            ;;
            img|ext4)
                make_losetup $path
                if [ -d $mount/${loop_seq}p2 ]; then
                    cp -r $mount/${loop_seq}p2/* $common_root
                elif [ -d $mount/${loop_seq}p1 ]; then
                    cp -r $mount/${loop_seq}p1/* $common_root
                elif [ -d $mount/${loop_seq} ]; then
                    cp -r $mount/${loop_seq}/* $common_root
                else
                    die "Error unpacking $path"
                fi
                break
            ;;
            *)
                die "Invalid format!"
            ;;
        esac
    done
    
    apply_patch

    rm -rf $common_root/lib/modules/*/
}

unpack_boot_kernel() {
    local path="$kernel_path/$kernel"
    common_boot="$tmp/core/kernel/$kernel/boot"
    last_device="$tmp/device/$device"

    local is_amlogic=false
    local is_allwinner=false
    local is_rockchip=false

    echo $amlogic | grep -iq $device && is_amlogic=true
    echo $allwinner | grep -iq $device && is_allwinner=true
    echo $rockchip | grep -iq $device && is_rockchip=true

    mkdir -p $common_boot
    tar xzf $path/boot-*.tar.gz -C $common_boot 2>/dev/null

    if [ $is_amlogic = true ]; then
        mkdir -p ${last_device}/$kernel/{boot,boot/dtb,boot/dtb/amlogic,root,root/lib/modules}
        tar xzf $kernel_path/$kernel/dtb-*.tar.gz -C ${last_device}/$kernel/boot/dtb/amlogic
    elif [ $is_allwinner = true ]; then
        mkdir -p ${last_device}/$kernel/{boot,boot/dtb,boot/dtb/allwinner,root,root/lib/modules}
        tar xzf $kernel_path/$kernel/dtb-*.tar.gz -C ${last_device}/$kernel/boot/dtb/allwinner
    elif [ $is_rockchip = true ]; then
        mkdir -p ${last_device}/$kernel/{boot,boot/dtb,boot/dtb/rockchip,root,root/lib/modules}
        tar xzf $kernel_path/$kernel/dtb-*.tar.gz -C ${last_device}/$kernel/boot/dtb/rockchip
    fi
    
    cp -r $common_boot/* ${last_device}/$kernel/boot
    cp -r $common_root/* ${last_device}/$kernel/root

    tar xzf $device_path/$device/boot-$device.tar.gz -C ${last_device}/$kernel/boot
    tar xzf $path/modules-*.tar.gz -C ${last_device}/$kernel/root/lib/modules
    (cd $tmp/device/$device/$kernel/root/lib/modules/$kernel/ && rm -f build source *.ko 2>/dev/null &&
    find ./ -type f -name '*.ko' -exec ln -s {} ./ \;)

    [ $(ls $device_path/$device/root | wc -l) = 0 ] || cp -r $device_path/$device/root/* ${last_device}/$kernel/root
    [ $(ls ./core/root | wc -l) = 0 ] || cp -r ./core/root/* ${last_device}/$kernel/root
}

make_image() {
    local image="$out/$device/$(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)-$device-k$kernel.img"
    [ -d $out/$device ] || mkdir -p $out/$device

    fallocate -l $((16 + 256 + rootsize))M $image

    parted -s $image mklabel msdos
    parted -s $image mkpart primary fat32 17M 273M
    parted -s $image mkpart primary ext4 273M 100%

    make_losetup $image 1

    local is_amlogic=false
    echo $amlogic | grep -iq $device && is_amlogic=true
    local is_rockchip=false
    echo $rockchip | grep -iq $device && is_rockchip=true
    local is_allwinner=false
    echo $allwinner | grep -iq $device && is_allwinner=true

    mkfs.vfat -n "BOOT" ${loop}p1 >/dev/null 2>&1
    mke2fs -F -q -t ext4 -L "ROOTFS" -m 0 ${loop}p2 >/dev/null 2>&1

    txtloader=""
    if [ $is_amlogic = true ]; then
        loader="./core/loader/amlogic/${device}.bin"
        txtloader="${device}.bin"
        dd if=$loader of=$loop bs=1 count=444 conv=fsync 2>/dev/null
        dd if=$loader of=$loop bs=512 skip=1 seek=1 conv=fsync 2>/dev/null
    fi

    if [ $is_allwinner = true ]; then
        loader="./core/loader/allwinner/u-boot-sunxi-with-spl-${device}.bin"
        loader1="./core/loader/allwinner/u-boot-mainline-${device}.bin"

        dd if=$loader of=$loop bs=8k seek=1 conv=fsync,notrunc 2>/dev/null
        if [ -f ${loader} ]; then
            dd if=$loader of=$loop bs=8k seek=1 conv=fsync,notrunc 2>/dev/null
            txtloader="${txtloader}u-boot-sunxi-with-spl-${device}.bin"
        fi
        if [ -f ${loader1} ]; then
            dd if=$loader1 of=$loop bs=8k seek=5 conv=fsync,notrunc 2>/dev/null
            txtloader="${txtloader} | u-boot-mainline-${device}.bin"
        fi
    fi
    
    if [ $is_rockchip = true ]; then
        loader="./core/loader/rockchip/idbloader-${device}.img"
        loader1="./core/loader/rockchip/u-boot-${device}.itb"
        loader2="./core/loader/rockchip/trust-${device}.bin"

        if [ -f ${loader} ]; then
            dd if=$loader of=$loop conv=fsync,notrunc bs=512 seek=64 2>/dev/null
            txtloader="${txtloader}idbloader-${device}.img"
        fi
        if [ -f ${loader1} ]; then
            dd if=$loader1 of=$loop conv=fsync,notrunc bs=512 seek=16384 2>/dev/null
            txtloader="${txtloader} | u-boot-${device}.itb"
        fi
        if [ -f ${loader2} ]; then
            dd if=$loader2 of=$loop conv=fsync,notrunc bs=512 seek=24576 2>/dev/null
            txtloader="${txtloader} | trust-${device}.bin"
        fi
    fi

    echo $txtloader > $rootfs_path/uboot.log
    losetup -d ${loop}

    make_losetup $image

    {
        set -e
        cp -r ${last_device}/$kernel/boot/* $mount/${loop_seq}p1
        cp -r ${last_device}/$kernel/root/* $mount/${loop_seq}p2

        (
            cd $mount/${loop_seq}p1
                if [ $is_allwinner = true ]; then
                    cp uInitrd-* uInitrd
                    cp vmlinuz-* Image
                elif [ $is_rockchip = true ]; then
                    cp uInitrd-* uInitrd
                    cp vmlinuz-* Image
                elif [ $is_amlogic = true ]; then
                    mv uInitrd-* uInitrd
                    mv vmlinuz-* zImage
                fi
        )

        lain_lain "$mount/${loop_seq}p2"
    }
}

lain_lain() {
    local path=$1
    
    [ -d $path ] && {
        mkdir -p $path/{boot,opt,run}

        local is_amlogic=false
        local is_allwinner=false
        local is_rockchip=false

        echo $amlogic | grep -iq $device && is_amlogic=true
        echo $allwinner | grep -iq $device && is_allwinner=true
        echo $rockchip | grep -iq $device && is_rockchip=true

        if [ $is_amlogic = true ]; then
            printf 'pwm_meson' > $path/etc/modules.d/pwm-meson
            sed -i 's/ttyAMA0/ttyAML0/' $path/etc/inittab
            sed -i 's/ttyS0/tty0/' $path/etc/inittab

            if ! grep -q '/tmp/upgrade' $path/etc/init.d/boot; then
                sed -i '/kmodloader/i\\tmkdir -p \/tmp\/upgrade' $path/etc/init.d/boot
            fi
        elif [ $is_allwinner = true ]; then
            sed -i 's/ttyAMA0/tty1/' $path/etc/inittab
            sed -i 's/ttyS0/ttyS2/' $path/etc/inittab
        elif [ $is_rockchip = true ]; then
            sed -i 's/ttyAMA0/tty1/' $path/etc/inittab
            sed -i 's/ttyS0/ttyS2/' $path/etc/inittab
        fi

        if ! grep -q 'ulimit -n' $path/etc/init.d/boot; then
            sed -i '/kmodloader/i\\tulimit -n 131072\n' $path/etc/init.d/boot
        fi
        
        wireless_mac80211="$path/lib/netifd/wireless/mac80211.sh"
        [[ -f "${wireless_mac80211}" ]] && {
            cp -f ${wireless_mac80211} ${wireless_mac80211}.bak
            sed -i "s|iw |ipconfig |g" ${wireless_mac80211}
        }

        rm -rf $path/lib/firmware/
        cp -rf $fwdriver_path/firmware $path/lib/
        chmod 777 $path/lib/firmware/*
        chown -R 0:0 $path
    }
}

set_rootsize() {
    local cnt=0

    while [ $cnt -lt 3 ]; do
        echo "Your rootfs size" | $lolcat -a -d 5
        echo "Input number (256 512 640 768 1024 1536) default ${minsize}" | $lolcat -a -d 5
        while read -r -t 0; do read -r; done
        read -p "" rootsize
        if [ ! "$rootsize" ]; then
            rootsize=$minsize
            break
        elif [[ "$rootsize" -ge "256" ]] 2>/dev/null; then
            break
        else
            ((cnt++))
            echo -e "Invalid input...\n"
            sleep 1s
        fi
    done

    [ $cnt = 3 ] && die "Too many invalid attempts Bye NooB, Exiting..."
}

extract_kernel() {
    choose_rootfs

    local path="$rootfs_path/$firmware"
    local suffix="${firmware##*.}"

    while true; do
        case "$suffix" in
            xz)
                [ -d $tmp ] || mkdir -p $tmp
                echo -e "Unpacking..."
                xz -dc $path > $tmp/${firmware%.*}
                path=$tmp/${firmware%.*}
                suffix=${path##*.}
            ;;
            img)
                make_losetup $path
                break
            ;;
            *)
                die "Invalid format!"
            ;;
        esac
    done

    local kversion=$(ls $mount/${loop_seq}p2/lib/modules)
    local version=$(echo $kversion | grep -oE '^[4-5].[0-9]+.[0-9]+')

    echo -e "Kernel version  =>  $kversion"

    mkdir -p $tmp/$version/{boot,boot/dtb,boot/dtb/amlogic,root/lib}
    cp -r $mount/${loop_seq}p1/{config-*,initrd.img-*,System.map-*,uInitrd-*,vmlinuz-*} $tmp/$version/boot
    cp -r $mount/${loop_seq}p2/lib/modules $tmp/$version/root/lib/modules/*

    (
        cd $tmp/$version/root/lib/modules/*/
        rm -rf *.ko
        find ./ -type f -name '*.ko' -exec ln -s {} ./ \;
    )

    if [ $is_amlogic = true ]; then
        echo -e "Package\t\t=>  dtb-*.tar.gz"
        cd $tmp/$version/boot/dtb/amlogic
        tar czf dtb-*.tar.gz * dtb/amlogic
        mv dtb-*.tar.gz ../
    elif [ $is_allwinner = true ]; then    
        echo -e "Package\t\t=>  dtb-*.tar.gz"
        cd $tmp/$version/boot/dtb/allwinner
        tar czf dtb-*.tar.gz * dtb/allwinner
        mv dtb-*.tar.gz ../
    elif [ $is_rockchip = true ]; then    
        echo -e "Package\t\t=>  dtb-*.tar.gz"
        cd $tmp/$version/boot/dtb/rockchip
        tar czf dtb-*.tar.gz * dtb/rockchip
        mv dtb-*.tar.gz ../
    fi
        
    (
        echo -e "Package\t\t=>  boot-$version.tar.gz"
        cd $tmp/$version/boot
        tar czf boot-$version.tar.gz *
        mv boot-$version.tar.gz ../
    )

    (
        echo -e "Package\t\t=>  modules-$version.tar.gz"
        cd $tmp/$version/root
        tar czf modules-$version.tar.gz lib/
        mv modules-$version.tar.gz ../
    )

    rm -rf $tmp/$version/{boot,root}

    [ -f $tmp/$version/boot-$version.tar.gz ] && [ -f $tmp/$version/modules-$version.tar.gz ] && {
        [ -d $kernel_path/$version ] && {
            echo && {
                while read -r -t 0; do read -r; done
                read -p "This version $(echo -e "${version}") Replace? [Y/n] " yn
            } && echo
            case "$yn" in
                n|N) yn=n ;;
                *) yn=y ;;
            esac
        }
        [[ ! "$yn" || "$yn" = "y" ]] && {
            [ -d $kernel_path ] || mkdir -p $kernel_path
            cp -r $tmp/$version $kernel_path
            chown -R 1000:1000 $kernel_path/$version
            echo -e "Done"
        }
    }

    cleaning
}

mount_image() {
    choose_rootfs

    local path="$rootfs_path/$firmware"
    local suffix="${firmware##*.}"

    while true; do
        case "$suffix" in
            xz)
                [ -d $tmp ] || mkdir -p $tmp
                echo -e "Unpacking..."
                xz -dc $path > $tmp/${firmware%.*}
                path=$tmp/${firmware%.*}
                suffix=${path##*.}
            ;;
            img)
                make_losetup $path
                break
            ;;
            *)
                die "Invalid format!"
            ;;
        esac
    done

    echo -e "Successfully mounted to ${mount:2}/${loop_seq}"
}

usage() {
    cat <<-EOF
Usage:
  ulo [options]

Options:
    -h, --help      : Show this Text
    -c, --clean     : Clean old cache
    -u, --update    : Update Kernel, ROOTFS, and Firmware files from ULO-Repository
                      (Will overwrite your old Kernel, ROOTFS, and Firmware files!!!)
    
    -y  --yes       : Custom ROOTFS Download
    -k              : Set the kernel       (-k 6.1.66-DBAI)
    -m              : Set the device       (-m s905x2)
    -r              : Set the rootfs files (-r immortalwrt-21.02.7-vanila-armvirt-64-default-rootfs.tar.gz)
    -s, --size=SIZE : Set size             (-s 1024)

EOF
}

[ $(id -u) = 0 ] || die "Please run this script as root"

check_depedencies

echo -e "
======================================================================
----------------------------------------------------------------------
                            ULO BUILDER 
                               v${ver}
                              By DBAI
----------------------------------------------------------------------
======================================================================
" | $lolcat -a -d 5

check_requirement_files

while [ "$1" ]; do
    case "$1" in
        -y|--yes)
            custom_rootfs_files "yes"
            exit
        ;;
        -h|--help)
            usage
            exit
        ;;
        -c|--clean)
            cleaning
            echo -e "Cleaning completed"
            exit
        ;;
        -u|--update)
            echo -e "Updating Kernel, ROOTFS, and Firmware files from ULO-Repository"
            download_requirement_files true
            exit
        ;;
        -d|--default)
            : ${device:="all"}
            : ${firmware:=${rootfs[0]}}
            : ${kernel:="all"}
            : ${rootsize:=$minsize}
        ;;
        -e)
            extract_kernel
            exit
        ;;
        -k)
            kernel=$2
            if [ -f $kernel_path/$kernel/dtb-*.tar.gz ] && \
               [ -f $kernel_path/$kernel/boot-*.tar.gz ] && \
               [ -f $kernel_path/$kernel/modules-*.tar.gz ]; then
                kernels=($kernel)
                kernel_checker "${kernels}" true
                shift
            else
                die "Invalid kernel $kernel"
            fi
        ;;
        -m)
            device=$2
            if [ -f $device_path/$device/boot-*.tar.gz ]; then
                devices=($device)
                shift
            elif [ "$device" = "all" ]; then
                [ ${#devices[*]} = 0 ] && unset device
                shift
            else
                die "Invalid device $device"
            fi
        ;;
        -r)
            rootf=$2
            if [ -f $rootfs_path/$rootf ]; then
                firmware=($rootf)
                echo $firmware > $rootfs_path/rootfs.log
                shift
            else
                die "Invalid rootfs $rootf"
            fi
        ;;
        --mount)
            mount_image
            exit
        ;;
        -s|--size)
            rootsize=$2
            if [[ "$rootsize" -ge "$minsize" ]] 2>/dev/null; then
                shift
            else
                die "Invalid rootsize $rootsize"
            fi
        ;;
        *)
            usage
            die "Invalid option $1"
        ;;
    esac
    shift
done

[ "$device" ] && {
    echo -en "device\t\t=>  "
    echo -e "${devices[@]}" | sed 's/ /, /g'
}
[ "$firmware" ] && {
    echo -en "rootfs\t\t=>  "
    echo -e "${firmware[@]}" | sed 's/ /, /g'
}
[ "$kernel" ] && {
    echo -en "kernel\t\t=>  "
    echo -e "${kernels[@]}" | sed 's/ /, /g'
}
[ "$rootsize" ] && echo -e "rootsize\t=>  $rootsize"
[ "$device" ] || [ "$firmware" ] || [ "$kernel" ] || [ "$rootsize" ] && echo 

[ "$device" ] || choose_device
[ "$firmware" ] || choose_rootfs
[ "$kernel" ] || choose_kernel
choose_patch
[ "$rootsize" ] || set_rootsize

unpack_openwrt
echo "Building in progress..." | $lolcat -a -d 5

for kernel in ${kernels[*]}; do
    for device in ${devices[*]}; do
    {
        unpack_boot_kernel
        make_image
    } &
    done
done

wait
Total_size="$((256+$rootsize))"
uboot=$(cat ${rootfs_path}/uboot.log | cut -d '/' -f5-6)

echo -e "Build Information :
    Device      = $device
    Kernel      = $kernel
    Rootfs      = $(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)
    Size        = $Total_size M
    U-boot      = ${uboot}" | $lolcat -a -d 5
echo "    Output file = out/$device/$(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)-$device-k$kernel.img.gz" | $lolcat -a -d 5
cleaning 0

pigz -qf $out/$device/$(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)-$device-k$kernel.img || gzip $out/$device/$(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)-$device-k$kernel.img
tot_time=$(($SECONDS - $start_cnt))
build_time=$(($SECONDS - $start_build))

echo "    Build Time  = $(($build_time/60))m $(($build_time%60))s" | $lolcat -a -d 5
echo "    Total Time  = $(($tot_time/60))m $(($tot_time%60))s" | $lolcat -a -d 5
echo -e 'Done...' | $lolcat -a -d 5
echo -e ""

while read -r -t 0; do read -r; done
read -p "Do you want to burn the image to a disk? (Y/N): " burn_opt
if [[ "$burn_opt" =~ ^[Yy]$ ]]; then
    gnome-disks --restore-disk-image="$out/$device/$(cat ${rootfs_path}/rootfs.log | cut -d '-' -f1-3)-$device-k$kernel.img.gz"
fi

chmod -R 777 $out
rm $rootfs_path/uboot.log
rm $rootfs_path/rootfs.log
